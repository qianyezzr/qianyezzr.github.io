{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/03/27/hello-world/"},{"title":"LongTimeNoSee","text":"s啥也不是！！","link":"/2021/03/27/LongTimeNoSee/"},{"title":"haha","text":"","link":"/2021/03/27/haha/"},{"title":"每日一题1:74. 搜索二维矩阵","text":"本质上是一道二分搜索题，二维上的。这里选择将二维转为一维通过求模取整。 123456789101112131415161718class Solution { public boolean searchMatrix(int[][] matrix, int target) { int m = matrix.length, n = matrix[0].length; int low = 0, high = m * n - 1; while (low &lt;= high) { int mid = (high - low) / 2 + low; int x = matrix[mid / n][mid % n];//注意这里的转换 if (x &lt; target) { low = mid + 1; } else if (x &gt; target) { high = mid - 1; } else { return true; } } return false; }} 还发现了另一种思路。（膜拜大佬） 作者:宫水三叶直接copy来了： 抽象 BST 解法我们可以将二维矩阵抽象成「以右上角为根的 BST」： 那么我们可以从根（右上角）开始搜索，如果当前的节点不等于目标值，可以按照树的搜索顺序进行： 当前节点「大于」目标值，搜索当前节点的「左子树」，也就是当前矩阵位置的「左方格子」，即 y–当前节点「小于」目标值，搜索当前节点的「右子树」，也就是当前矩阵位置的「下方格子」，即 x++ 123456789101112131415161718class Solution { int m, n; public boolean searchMatrix(int[][] mat, int t) { m = mat.length; n = mat[0].length; int x = 0, y = n - 1; while (check(x, y) &amp;&amp; mat[x][y] != t) { if (mat[x][y] &gt; t) { y--; } else { x++; } } return check(x, y) &amp;&amp; mat[x][y] == t; } boolean check(int x, int y) { return x &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n; }} 任重而道远！","link":"/2021/03/30/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981/"}],"tags":[{"name":"11","slug":"11","link":"/tags/11/"}],"categories":[]}